# Soporte: https://www.linkedin.com/in/oscarlizarragag/

# Este script utiliza la funci칩n matem치tica de **prueba de divisibilidad** para verificar si un n칰mero es primo.

# \# Un n칰mero primo ($p$) es un n칰mero natural mayor que 1 que tiene exactamente dos divisores positivos distintos: 1 y 칠l mismo.

# \# La prueba de divisibilidad solo necesita verificar divisores hasta la ra칤z cuadrada ($\sqrt{p}$) del n칰mero.

```python
import math

def es_primo(numero):
    """
    Verifica si un n칰mero entero es primo.
    
    :param numero: El n칰mero a verificar.
    :return: True si es primo, False si no lo es.
    """
    # 0 y 1 no son primos por definici칩n
    if numero <= 1:
        return False
    
    # 2 y 3 son primos
    if numero <= 3:
        return True
        
    # Un optimizaci칩n: los n칰meros mayores que 3 pueden expresarse como 6k 췀 1.
    # # Si el n칰mero es divisible por 2 o por 3, no es primo.
    if numero % 2 == 0 or numero % 3 == 0:
        return False
        
    # La verificaci칩n solo necesita ir hasta la ra칤z cuadrada del n칰mero.
    # # Usamos `int(math.sqrt(numero))` para el l칤mite superior.
    i = 5
    while i * i <= numero:
        # # Verificamos si es divisible por i o i + 2
        # # Esto cubre todos los divisores primos restantes (6k 췀 1)
        if numero % i == 0 or numero % (i + 2) == 0:
            return False
        i += 6 # Saltar al siguiente potencial divisor (6k + 5)
        
    return True

def generar_primos_hasta_n(limite_n):
    """
    Genera una lista de todos los n칰meros primos hasta un l칤mite N (inclusive).

    :param limite_n: El n칰mero entero m치ximo a considerar.
    :return: Una lista de n칰meros primos.
    """
    # Manejo de entrada inv치lida
    if not isinstance(limite_n, int) or limite_n < 2:
        return []

    # Lista donde se almacenar치n los n칰meros primos encontrados
    primos_encontrados = []
    
    # Itera desde 2 hasta el l칤mite N (incluido)
    for numero in range(2, limite_n + 1):
        # # Llama a la funci칩n auxiliar para verificar si es primo
        if es_primo(numero):
            primos_encontrados.append(numero)
            
    return primos_encontrados

# --- Bloque Principal de Ejecuci칩n ---

# # 1. Define el l칤mite N (cambia este valor para probar diferentes rangos)
LIMITE_N = 100

print("# --- GENERADOR DE N칔MEROS PRIMOS ---")
print(f"# Objetivo: Listar los n칰meros primos hasta {LIMITE_N}")

# # 2. Llama a la funci칩n principal para obtener la lista de primos
lista_de_primos = generar_primos_hasta_n(LIMITE_N)

# # 3. Muestra los resultados
if lista_de_primos:
    print(f"\n# Se encontraron {len(lista_de_primos)} n칰meros primos.")
    print("# Lista de n칰meros primos:")
    
    # # Imprime la lista de una forma legible, agrupando los n칰meros
    # # # Se usa una comprensi칩n de lista para convertir los n칰meros a string para la impresi칩n
    primos_str = [str(p) for p in lista_de_primos]
    # # Une los strings con coma y espacio
    print("# " + ", ".join(primos_str))
    
else:
    print("# No se encontraron n칰meros primos en el rango especificado.")
    
print("# -----------------------------------")
```

## 游닇 Ejemplo de Salida para $N=100$

# La ejecuci칩n del script con `LIMITE_N = 100` producir치 la siguiente lista:

# Lista de n칰meros primos:

# 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97

-----

## 游눠 Opci칩n de Rendimiento

# Para l칤mites $N$ muy grandes (por ejemplo, $N > 10000$), la funci칩n `generar_primos_hasta_n` es **ineficiente**.

# \# Una t칠cnica mucho m치s r치pida y recomendada para generar listas grandes de primos es la **Criba de Erat칩stenes**.

