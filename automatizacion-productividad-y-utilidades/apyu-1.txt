# Soporte: https://www.linkedin.com/in/oscarlizarragag/

# Este script utiliza el m√≥dulo est√°ndar **`hashlib`** para calcular el hash y **`os`** para navegar por el sistema de archivos.

```python
import hashlib
import os
from collections import defaultdict
from tkinter import filedialog, Tk, messagebox

def calcular_hash_archivo(ruta_archivo, algoritmo='sha256', tama√±o_bloque=65536):
    """
    Calcula el hash criptogr√°fico de un archivo grande.

    :param ruta_archivo: La ruta completa al archivo.
    :param algoritmo: El algoritmo de hash a usar ('sha256' es un buen est√°ndar).
    :param tama√±o_bloque: Tama√±o del bloque (en bytes) para leer el archivo.
    :return: El resumen del hash en formato hexadecimal o None si hay error.
    """
    # 1. Inicializar el objeto hash
    try:
        hasher = hashlib.new(algoritmo)
    except ValueError:
        print(f"Error: Algoritmo de hash '{algoritmo}' no soportado.")
        return None

    # 2. Leer el archivo en bloques
    try:
        # # Abre el archivo en modo binario ('rb')
        with open(ruta_archivo, 'rb') as archivo:
            # # Leer el primer bloque
            buffer = archivo.read(tama√±o_bloque)
            # # Bucle para leer todo el archivo
            while len(buffer) > 0:
                hasher.update(buffer)
                buffer = archivo.read(tama√±o_bloque)
                
        # 3. Devolver el hash final
        return hasher.hexdigest()
        
    except FileNotFoundError:
        # # Archivo no encontrado, lo ignoramos y devolvemos None
        return None
    except Exception as e:
        # # Otros errores de lectura o permiso
        print(f"Error al procesar el archivo {ruta_archivo}: {e}")
        return None


def escanear_directorio_en_busca_de_duplicados(directorio_raiz):
    """
    Escanea un directorio y sus subdirectorios para encontrar archivos duplicados.
    
    :param directorio_raiz: La ruta de la carpeta a escanear.
    :return: Un diccionario donde la clave es el hash y el valor es una lista de rutas de archivo.
    """
    # # `defaultdict(list)` crea un diccionario donde el valor por defecto de una clave 
    # # # nueva es una lista vac√≠a. Esto simplifica la adici√≥n de rutas al hash.
    hashes_por_tama√±o = defaultdict(list)
    hashes_por_contenido = defaultdict(list)
    
    contador_archivos = 0
    
    print(f"# Paso 1: Escaneando archivos y agrupando por tama√±o en: {directorio_raiz}")

    # 1. Primera pasada: Agrupar por tama√±o (Optimizaci√≥n)
    # # Itera a trav√©s de todos los archivos en el directorio_raiz y sus subdirectorios
    for dirpath, dirnames, filenames in os.walk(directorio_raiz):
        for nombre_archivo in filenames:
            ruta_completa = os.path.join(dirpath, nombre_archivo)
            
            # # Ignorar enlaces simb√≥licos (para evitar bucles o errores de permisos)
            if not os.path.islink(ruta_completa):
                try:
                    # # Obtener el tama√±o del archivo
                    tama√±o = os.path.getsize(ruta_completa)
                    hashes_por_tama√±o[tama√±o].append(ruta_completa)
                    contador_archivos += 1
                except Exception:
                    # # Ignorar archivos con problemas de permiso/acceso
                    pass

    print(f"# Encontrados {contador_archivos} archivos. {len(hashes_por_tama√±o)} tama√±os √∫nicos.")
    print("# Paso 2: Calculando hashes para archivos con tama√±o duplicado...")

    # 2. Segunda pasada: Calcular hash solo para grupos con m√°s de un archivo
    archivos_procesados_hash = 0
    for tama√±o, rutas in hashes_por_tama√±o.items():
        # # Solo nos interesa procesar los grupos donde el tama√±o se repite (> 1 archivo)
        if len(rutas) > 1:
            for ruta in rutas:
                # # Calcular el hash SHA256 para el contenido
                archivo_hash = calcular_hash_archivo(ruta)
                archivos_procesados_hash += 1
                
                if archivo_hash:
                    hashes_por_contenido[archivo_hash].append(ruta)
                    
    print(f"# {archivos_procesados_hash} archivos con tama√±o repetido procesados por hash.")

    # 3. Filtrar y devolver solo los duplicados reales (hash repetido)
    duplicados = {
        hash_val: rutas 
        for hash_val, rutas in hashes_por_contenido.items() 
        if len(rutas) > 1
    }

    return duplicados


def mostrar_resultados(duplicados):
    """
    Muestra los resultados de la b√∫squeda en la consola.
    """
    total_grupos = len(duplicados)
    total_duplicados = sum(len(rutas) - 1 for rutas in duplicados.values())
    
    print("\n# === RESULTADOS DE ARCHIVOS DUPLICADOS ===")
    
    if total_grupos == 0:
        print("# ¬°√âxito! No se encontraron archivos id√©nticos por hash en el directorio.")
        return

    print(f"## ‚ùó Encontrados {total_grupos} grupos de archivos duplicados.")
    print(f"## üóëÔ∏è Total de archivos duplicados (excluyendo el original): {total_duplicados}\n")

    # # Imprimir los grupos de duplicados
    for i, (hash_val, rutas) in enumerate(duplicados.items()):
        print(f"### Grupo {i+1} (Hash: {hash_val[:10]}...):")
        # # La primera ruta es el "original" (aunque todos son iguales)
        print(f"# Archivo Original (Mantener): {rutas[0]}")
        # # El resto son los duplicados a considerar eliminar
        print("# --- Duplicados a Eliminar ---")
        for ruta_duplicada in rutas[1:]:
            print(f"# -> {ruta_duplicada}")
        print("# ----------------------------------\n")
        
    print("# === FIN DEL AN√ÅLISIS ===")


# --- Bloque Principal de Ejecuci√≥n (con GUI para seleccionar carpeta) ---

def main():
    # # Ocultar la ventana ra√≠z de Tkinter (solo la necesitamos para el di√°logo)
    root = Tk()
    root.withdraw() 
    
    print("# --- DETECTOR DE ARCHIVOS DUPLICADOS ---")
    
    # # Abrir di√°logo para seleccionar la carpeta a escanear
    directorio_a_escanear = filedialog.askdirectory(title="Seleccione el directorio ra√≠z a escanear")
    
    if not directorio_a_escanear:
        print("# Operaci√≥n cancelada por el usuario.")
        return
        
    if not os.path.isdir(directorio_a_escanear):
        messagebox.showerror("Error", "La ruta seleccionada no es un directorio v√°lido.")
        return

    # # Ejecutar el escaneo
    duplicados_encontrados = escanear_directorio_en_busca_de_duplicados(directorio_a_escanear)
    
    # # Mostrar los resultados
    mostrar_resultados(duplicados_encontrados)

if __name__ == "__main__":
    main()
```

## üìù Instrucciones para Usar el Programa

1.  **Guarda el c√≥digo:** Guarda el c√≥digo Python anterior en un archivo, por ejemplo, `detector_duplicados.py`.
2.  **Ejecuta el script:** Abre tu terminal y ejecuta:
    ```bash
    python detector_duplicados.py
    ```
3.  **Selecciona la Carpeta:** Se abrir√° una ventana de di√°logo pidi√©ndote que selecciones la carpeta que deseas escanear (incluir√° subcarpetas).
4.  **Revisa los Resultados:** El script imprimir√° en la consola los grupos de archivos id√©nticos que encontr√≥, junto con su hash y la ruta de cada duplicado.

# La aplicaci√≥n utiliza una **optimizaci√≥n de dos fases**: primero agrupa los archivos por **tama√±o** y solo calcula el hash (`sha256`) para aquellos grupos que tienen m√°s de un archivo. Esto reduce dr√°sticamente el tiempo de procesamiento, ya que los archivos con diferente tama√±o nunca pueden ser duplicados.




