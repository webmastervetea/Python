# Soporte: https://www.linkedin.com/in/oscarlizarragag/


# Este script requiere que la librer√≠a **requests** est√© instalada.

# \# Puedes instalarla con `pip install requests`.

```python
import requests
import os
import sys
import tkinter as tk
from tkinter import filedialog, messagebox
from urllib.parse import urlparse # √ötil para la validaci√≥n b√°sica de URL

# --- CONFIGURACI√ìN ---

# # Tiempo m√°ximo de espera (timeout) para la conexi√≥n HTTP en segundos
TIMEOUT_SECONDS = 10 
# # User-Agent para simular un navegador real y evitar el bloqueo por algunos sitios
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
# # C√≥digos de estado HTTP que se consideran un enlace roto (adem√°s de los errores de conexi√≥n)
CODIGOS_ROTO = [400, 403, 404, 405, 410, 500, 503]

def verificar_url(url):
    """
    Realiza una solicitud HEAD a una URL y determina su estado.

    :param url: La URL a verificar.
    :return: Una tupla (estado_simb√≥lico, c√≥digo_http)
    """
    # 1. Asegurar el esquema HTTP/HTTPS (requests lo requiere)
    if not url.startswith('http'):
        url = 'http://' + url
        
    # 2. Validar sintaxis b√°sica (opcional, pero √∫til)
    parsed_url = urlparse(url)
    if not parsed_url.netloc:
        return "URL Inv√°lida", 0

    # 3. Realizar la solicitud HTTP (HEAD es m√°s r√°pido que GET)
    try:
        # # `allow_redirects=True` sigue redirecciones (3xx)
        # # # `stream=True` asegura que no descargamos el contenido
        response = requests.head(url, 
                                 timeout=TIMEOUT_SECONDS, 
                                 allow_redirects=True,
                                 headers={'User-Agent': USER_AGENT})
        
        # # Si la solicitud HEAD falla, intentar con GET (algunos servidores lo bloquean)
        if response.status_code >= 400:
             response = requests.get(url, 
                                     timeout=TIMEOUT_SECONDS, 
                                     allow_redirects=True,
                                     headers={'User-Agent': USER_AGENT},
                                     stream=True)
                                     
        codigo = response.status_code
        
        # 4. Clasificar el estado
        if codigo < 400:
            return "‚úÖ OK", codigo
        elif codigo in CODIGOS_ROTO:
            return "‚ùå ROTO", codigo
        else:
            return "‚ö†Ô∏è OTRO ERROR HTTP", codigo

    except requests.exceptions.Timeout:
        return "‚ùå TIMEOUT", 0
    except requests.exceptions.ConnectionError:
        return "‚ùå CONEXI√ìN FALLIDA", 0
    except requests.exceptions.RequestException as e:
        return f"‚ùå ERROR DE PETICI√ìN ({type(e).__name__})", 0
    except Exception:
        return "‚ùå ERROR DESCONOCIDO", 0


def escanear_enlaces_archivo(ruta_archivo):
    """
    Lee un archivo de texto con URLs y verifica cada una.

    :param ruta_archivo: Ruta del archivo que contiene una URL por l√≠nea.
    """
    
    # 1. Inicializar listas de resultados
    urls_a_verificar = []
    
    # 2. Leer las URLs del archivo
    try:
        with open(ruta_archivo, 'r', encoding='utf-8') as f:
            for linea in f:
                url = linea.strip()
                if url: # Asegurarse de que la l√≠nea no est√© vac√≠a
                    urls_a_verificar.append(url)
    except FileNotFoundError:
        messagebox.showerror("Error", "El archivo de origen no fue encontrado.")
        return
    except Exception as e:
        messagebox.showerror("Error", f"Error al leer el archivo: {e}")
        return

    print(f"# ‚è≥ Iniciando verificaci√≥n de {len(urls_a_verificar)} URL(s)...")
    
    resultados = {
        'ok': [],
        'roto': [],
        'otros': []
    }
    
    # 3. Bucle de verificaci√≥n
    for i, url in enumerate(urls_a_verificar):
        estado, codigo = verificar_url(url)
        
        # # Mostrar progreso en la consola
        print(f"#{i+1:02d}. {estado:<15} ({codigo}) | {url}")
        
        # # Clasificar el resultado
        if estado == "‚úÖ OK":
            resultados['ok'].append((url, codigo))
        elif estado.startswith("‚ùå"):
            resultados['roto'].append((url, codigo))
        else:
            resultados['otros'].append((url, codigo))

    # 4. Mostrar resumen final
    print("\n# === RESUMEN DE LA VERIFICACI√ìN ===")
    print(f"## ‚úÖ OK: {len(resultados['ok'])} enlaces")
    print(f"## ‚ùå ROTOS/FALLIDOS: {len(resultados['roto'])} enlaces")
    print(f"## ‚ö†Ô∏è OTROS ERRORES: {len(resultados['otros'])} enlaces")
    print("-----------------------------------")
    
    if resultados['roto']:
        print("## LISTA DE ENLACES ROTOS (FALLIDOS):")
        for url, codigo in resultados['roto']:
            print(f"# [C√ìDIGO: {codigo}] -> {url}")
            
    messagebox.showinfo("Verificaci√≥n Completa", 
                        f"Verificaci√≥n finalizada:\nOK: {len(resultados['ok'])}\nROTO: {len(resultados['roto'])}\nOTROS: {len(resultados['otros'])}")


# --- Bloque Principal de Ejecuci√≥n (con GUI para seleccionar archivo) ---

def main():
    # # Inicializar Tkinter para los di√°logos gr√°ficos
    root = tk.Tk()
    root.withdraw() 
    
    print("# --- VERIFICADOR DE ENLACES ROTOS ---")
    
    # # Abrir di√°logo para seleccionar el archivo de texto
    ruta_archivo = filedialog.askopenfilename(
        title="Seleccione un archivo de texto (.txt) con URLs (una por l√≠nea)",
        filetypes=[("Archivos de Texto", "*.txt")]
    )
    
    if not ruta_archivo:
        print("# Operaci√≥n cancelada por el usuario. Saliendo.")
        sys.exit(0)
        
    escanear_enlaces_archivo(ruta_archivo)

if __name__ == "__main__":
    # # Verificar dependencias
    try:
        import requests
    except ImportError:
        print("# ERROR: La librer√≠a requests es requerida.")
        print("# Por favor, inst√°lala: pip install requests")
        sys.exit(1)
        
    main()
```

## üìù Instrucciones para Usar el Programa

1.  **Instala la librer√≠a `requests`:** Abre tu terminal y ejecuta:
    ```bash
    pip install requests
    ```
2.  **Crea el archivo de URLs:** Crea un archivo de texto simple (ejemplo: `enlaces.txt`) y coloca una URL por l√≠nea:
    ```
    https://www.google.com
    https://estaesunarotax.com/404
    http://wikipedia.org
    https://unservidorqueexisteperoestacaido.net
    ```
3.  **Guarda el c√≥digo:** Guarda el c√≥digo Python anterior en un archivo, por ejemplo, `verificador_enlaces.py`.
4.  **Ejecuta el script:** Abre tu terminal y ejecuta:
    ```bash
    python verificador_enlaces.py
    ```
5.  **Selecciona el Archivo:** Se abrir√° una ventana de di√°logo. Selecciona tu archivo `enlaces.txt`.
6.  **Revisa los Resultados:** El script imprimir√° el estado de cada URL en tiempo real en la consola y mostrar√° un resumen final, listando los enlaces fallidos.

# El script utiliza el m√©todo **`HEAD`** para verificar los enlaces r√°pidamente sin descargar el contenido de la p√°gina, lo que lo hace muy eficiente.




