# Soporte: https://www.linkedin.com/in/oscarlizarragag/

# Este script utiliza el m√≥dulo **os** para la navegaci√≥n de archivos

# \# y **tkinter** para la interfaz gr√°fica.

```python
import os
import sys
import tkinter as tk
from tkinter import filedialog, messagebox
from collections import defaultdict

# --- CONFIGURACI√ìN ---

# # Extensiones de archivo a incluir en el conteo. 
# # # A√±ade otras si trabajas con JavaScript (.js), Java (.java), etc.
EXTENSIONES_VALIDAS = ('.py', '.txt') 
# # Caracteres o patrones que indican una l√≠nea de comentario
COMENTARIOS_PYTHON = ('#', '"""', "'''")

def es_linea_de_codigo(linea):
    """
    Verifica si una l√≠nea contiene c√≥digo ejecutable/significativo,
    excluyendo l√≠neas vac√≠as o de comentario.

    :param linea: La l√≠nea de texto a evaluar.
    :return: True si es c√≥digo, False si es comentario o vac√≠o.
    """
    linea_limpia = linea.strip()
    
    # 1. Excluir l√≠neas completamente vac√≠as
    if not linea_limpia:
        return False
        
    # 2. Excluir l√≠neas de comentario de Python ('#')
    if linea_limpia.startswith(COMENTARIOS_PYTHON[0]):
        return False
        
    # 3. Excluir l√≠neas que son solo el inicio/fin de docstrings o comentarios multil√≠nea
    # # No es una verificaci√≥n perfecta para docstrings complejos, pero cubre el caso com√∫n.
    if linea_limpia == COMENTARIOS_PYTHON[1] or linea_limpia == COMENTARIOS_PYTHON[2]:
        return False
        
    return True

def contar_lineas_en_archivo(ruta_archivo):
    """
    Cuenta las l√≠neas significativas de c√≥digo en un archivo.

    :param ruta_archivo: Ruta del archivo.
    :return: Tupla (total_lineas, lineas_codigo, lineas_comentario)
    """
    total = 0
    codigo = 0
    comentario = 0
    dentro_de_docstring = False
    
    # # Patrones para detectar el inicio/fin de docstrings
    docstring_inicio = COMENTARIOS_PYTHON[1] 
    docstring_fin = COMENTARIOS_PYTHON[2] 

    try:
        with open(ruta_archivo, 'r', encoding='utf-8', errors='ignore') as f:
            for linea in f:
                total += 1
                linea_limpia = linea.strip()
                
                # Manejo de docstrings multil√≠nea (muy simplificado)
                if linea_limpia.startswith(docstring_inicio) or linea_limpia.startswith(docstring_fin):
                    # # Si encontramos un inicio, cambiamos el estado
                    if not dentro_de_docstring:
                        dentro_de_docstring = True
                        comentario += 1
                    # # Si encontramos un fin, cambiamos el estado
                    elif dentro_de_docstring:
                        dentro_de_docstring = False
                        comentario += 1
                    continue
                
                if dentro_de_docstring:
                    comentario += 1
                    continue
                
                if es_linea_de_codigo(linea):
                    codigo += 1
                else:
                    # # Si no es c√≥digo y no es vac√≠o, asumimos que es comentario de una sola l√≠nea
                    if linea_limpia:
                        comentario += 1

    except Exception:
        # # Error de lectura (permiso o codificaci√≥n)
        return total, -1, -1 

    return total, codigo, comentario


def escanear_directorio(directorio_raiz):
    """
    Recorre el directorio y sus subdirectorios contando las l√≠neas de c√≥digo.
    """
    # # Almacenar los resultados por extensi√≥n: {ext: [total_l, total_c, total_com]}
    resultados_globales = defaultdict(lambda: [0, 0, 0]) 
    archivos_analizados = 0
    
    print(f"\n# üîç Iniciando conteo de l√≠neas de c√≥digo en: {directorio_raiz}")

    for dirpath, dirnames, filenames in os.walk(directorio_raiz):
        for nombre_archivo in filenames:
            
            # 1. Verificar la extensi√≥n
            nombre_base, extension = os.path.splitext(nombre_archivo)
            if extension.lower() in EXTENSIONES_VALIDAS:
                ruta_completa = os.path.join(dirpath, nombre_archivo)
                archivos_analizados += 1
                
                # 2. Contar las l√≠neas
                total, codigo, comentario = contar_lineas_en_archivo(ruta_completa)
                
                if codigo != -1:
                    resultados_globales[extension][0] += total
                    resultados_globales[extension][1] += codigo
                    resultados_globales[extension][2] += comentario
                
                    print(f"# Analizado: {nombre_archivo:<30} | C√≥digo: {codigo:<5} | Comentarios: {comentario}")
                else:
                    print(f"# ‚ùå Error de lectura/permisos en: {nombre_archivo}")
    
    return resultados_globales, archivos_analizados


def mostrar_resumen_global(resultados, archivos_analizados):
    """
    Muestra el resumen final del conteo de l√≠neas.
    """
    total_loc = sum(res[1] for res in resultados.values())
    total_general = sum(res[0] for res in resultados.values())
    total_comentarios = sum(res[2] for res in resultados.values())
    
    print("\n# === RESUMEN GLOBAL DEL CONTEO LOC ===")
    print(f"## üìÅ Archivos analizados: {archivos_analizados}")
    print(f"## üìù Total de L√≠neas Contadas: {total_general}")
    print(f"{COLOR_OK}## üíª L√≠neas de C√≥digo (LOC): {total_loc}{COLOR_RESET}")
    print(f"{COLOR_WARNING}## üí¨ L√≠neas de Comentario: {total_comentarios}{COLOR_RESET}")
    print("---------------------------------------")
    
    if total_loc > 0:
        print("\n# DETALLE POR EXTENSI√ìN:")
        for ext, (t, c, co) in resultados.items():
            if c > 0:
                print(f"# {ext.upper():<5} | C√≥digo: {c:<7} | Comentario: {co}")
    
    messagebox.showinfo("Conteo Finalizado", f"An√°lisis LOC completado:\nL√≠neas de C√≥digo (LOC): {total_loc}\nTotal de Comentarios: {total_comentarios}")


# --- Bloque Principal de Ejecuci√≥n (con GUI para seleccionar carpeta) ---

def main():
    # # Inicializar Tkinter para los di√°logos gr√°ficos
    root = tk.Tk()
    root.withdraw() 
    
    # # Definir colores para el resumen
    global COLOR_OK, COLOR_WARNING
    COLOR_OK = "\033[92m" 
    COLOR_WARNING = "\033[93m" 
    COLOR_RESET = "\033[0m"

    print("# --- CONTADOR DE L√çNEAS DE C√ìDIGO (LOC) ---")
    
    # # Abrir di√°logo para seleccionar la carpeta a escanear
    directorio_a_escanear = filedialog.askdirectory(title="Seleccione la carpeta ra√≠z del proyecto a analizar")
    
    if not directorio_a_escanear:
        print("# Operaci√≥n cancelada por el usuario. Saliendo.")
        sys.exit(0)
        
    # # Ejecutar el escaneo
    resultados_globales, archivos_analizados = escanear_directorio(directorio_a_escanear)
    
    # # Mostrar los resultados
    mostrar_resumen_global(resultados_globales, archivos_analizados)

if __name__ == "__main__":
    main()
```

## üìù Instrucciones para Usar el Programa

1.  **Guarda el c√≥digo:** Guarda el c√≥digo Python anterior en un archivo, por ejemplo, `contador_loc.py`.
2.  **Ajusta las Extensiones:** Edita la lista `EXTENSIONES_VALIDAS` en la secci√≥n de CONFIGURACI√ìN si deseas incluir otros tipos de archivos de c√≥digo (por ejemplo, `.js`, `.c`, `.html`).
3.  **Ejecuta el script:** Abre tu terminal y ejecuta:
    ```bash
    python contador_loc.py
    ```
4.  **Selecciona la Carpeta:** Se abrir√° una ventana de di√°logo. Selecciona la carpeta que contiene tu proyecto de c√≥digo.
5.  **Revisa los Resultados:** El script escanear√° todos los archivos v√°lidos e imprimir√° en la consola el conteo detallado por archivo y un resumen final con el **Total de L√≠neas de C√≥digo (LOC)** y comentarios.

# La l√≥gica de conteo intenta activamente excluir l√≠neas que solo contienen comentarios de una sola l√≠nea (`#`) o que est√°n completamente en blanco, proporcionando una m√©trica m√°s precisa de la cantidad de c√≥digo significativo.




